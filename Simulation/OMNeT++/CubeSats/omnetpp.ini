
#								#
# 			Clusters			#
#								#

[Config Clusters]
# TODO: Seperate ini files
network = Base
sim-time-limit = 50s
#sim-time-limit.param-record-as-scalar = true

#repeat = 0
#seed-set = ${runnumber} # this is the default

# Random Numbers
#
num-rngs = 3
**.mobility.rng-0 = 1
**.wlan[*].mac.rng-0 = 2

# Network & Routing
#
# IPv4NetworkLayer
**.networkLayer.arpType = "GlobalARP"
**.networkLayer.proxyARP = true
# IPv4NetworkLayer -> IPv4NodeConfigurator
**.configurator.addStaticRoutes = true
**.configurator.configureRoutingTable = true
# IPv4NetworkLayer -> IPv4
**.networkLayer.ip.procDelay = 0s
**.networkLayer.ip.timeToLive = 32
**.networkLayer.ip.multicastTimeToLive = 32 
**.networkLayer.ip.fragmentTimeout = 60s
**.networkLayer.ip.forceBroadcast = false
**.networkLayer.ip.useProxyARP = true
# IPv4RoutingTable
**.routingTable.routerId = "auto"
**.routingTable.netmaskRoutes = "*"
**.routingTable.forwarding = true
**.routingTable.multicastForwarding = false
**.routingTable.routingFile = ""

# AODVRouting
**.aodv.askGratuitousRREP = false # see RFC 3561: 6.6.3
**.aodv.useHelloMessages = false # see RFC 3561: 6.9 # Default false --- An analogue for beacons perhaps ---
**.aodv.useLocalRepair = false # see RFC 3561: 6.12 --- not implemented yet ---
**.aodv.udpPort = 654
#**.aodv.maxPeriodicJitter = helloInterval * 0.25
#**.aodv.periodicJitter = uniform(0s, maxPeriodicJitter)
**.aodv.maxJitter = 5ms # 
#**.aodv.jitter = uniform(0ms, maxJitter) # jitter for broadcasts
**.aodv.helloInterval = 1s # every helloInterval seconds a node broadcasts Hello messages (if it is necessary)
**.aodv.allowedHelloLoss = 2 # allowedHelloLoss * helloInterval is the lifetime value for Hello messages
**.aodv.activeRouteTimeout = 3s # D:3s
**.aodv.netDiameter = ${NM} - 1 # D:35 the maximum possible number of hops between two nodes in the network
**.aodv.nodeTraversalTime = 0.04s # D:0.04s an estimation of the average one-hop traversal time
**.aodv.rerrRatelimit = 10 # maximum number of RERR messages that the AODV may originate in 1s.
**.aodv.rreqRetries = 2 # D:2 specifies the number of times AODV will repeat an expanded ring search for a destination
**.aodv.rreqRatelimit = 10 # maximum number of RREQ messages that the AODV may originate in 1s.
**.aodv.timeoutBuffer = 2 # D:2  plus time to wait for a delayed RREP (due to congestion)(to omit this buffer set it to 0)
**.aodv.ttlStart = 2 # specifies the TTL value when initiating a route request
**.aodv.ttlIncrement = 2 # specifies the value by which the TTL will be incremented each time a RREQ is retransmitted
**.aodv.ttlThreshold = 7 # the maximum value of TTL over which NET_DIAMETER value will be used to broadcast any RREQ
**.aodv.localAddTTL = 2 # it is used by the formula which calculates the initial TTL of the RREQ for a local repair
#**.aodv.myRouteTimeout = 2 * activeRouteTimeout # the value of the lifetime field that a destination node places in RREPs
#**.aodv.deletePeriod = 5 * max(activeRouteTimeout, helloInterval) # the time after which an expired route is deleted
#**.aodv.netTraversalTime = 2 * nodeTraversalTime * netDiameter # an estimation of the traversal time for the complete network
#**.aodv.blacklistTimeout = rreqRetries * netTraversalTime # the time after which a blacklisted node is removed from the blacklist
#**.aodv.nextHopWait = nodeTraversalTime + 0.01s # timeout for a RREP-ACK
#**.aodv.pathDiscoveryTime = 2 * netTraversalTime # buffer timeout for each broadcasted RREQ message

# Cluster Numbers
#
# TODO: Make better use of iteration variables
#*.numMasters = ${NM=4..6}
*.numMasters = ${NM=4}
#*.slavesPerMaster = ${SPM=1..3}
*.slavesPerMaster = ${SPM=2}
*.numSlaves = ${NS=(${NM})*(${SPM})}
*.slaveSeperation = ${SS=10deg}

# Medium
#
*.radioMediumType = "IdealRadioMedium"
*.radioMedium.mediumLimitCache.maxTransmissionDuration= 999s
*.radioMedium.mediumLimitCache.minInterferenceTime = 999s
*.radioMedium.propagationType = "ConstantTimePropagation" # Doesn't affect transmission durations which is bits/bitrate
*.radioMedium.**.propagationTime = 0s

# Application
#
*.node**.numUdpApps = 1
*.nodeMaster[0].udpApp[*].typename = "UDPSink"
*.node**.udpApp[*].typename = "UDPBasicApp" # The rest

# --- Sink
**.udpApp[*].localPort = 5000

# --- App
**.udpApp[*].destAddresses = "nodeMaster[0]"
**.udpApp[*].packetName = "UDP" + substringBefore(substringAfter(fullPath(), ".node"), ".udp")
**.udpApp[*].destPort = 5000
**.udpApp[*].messageLength = ${ML = 32, 64, 128, 256}B # DemoData
#**.udpApp[*].messageLength = ${ML = 128}B
**.udpApp[*].messageLength.param-record-as-scalar = true
*.dummySend = ${SI=0.25, 0.5, 1} # DemoData
**.sendInterval = truncnormal(${SI}s, (${SI} * 0.1s)) # DemoData
#**.sendInterval = 1s
#**.udpApp[*].startTime = ${SD} * ${NM} * 5ms # Five frames
**.udpApp[*].startTime = 10s
**.udpApp[*].stopTime = 20s
**.udpApp[*].stopTime.param-record-as-scalar = true

# NIC 
#
*.node**.wlan[*].typename = "WirelessNic"
# MAC
#
*.node**.macType = "CubeMacLayer"
*.node**.mac.address = "auto"
*.node**.mac.bitrate = 2Mbps
#*.node**.mac.slotDuration = ${SD = 10, 25, 50, 75, 100}ms
*.node**.mac.slotDuration = ${SD = 100}ms
**.mac.slotDuration.param-record-as-scalar = true
*.node**.mac.headerLength = 10B
*.node**.mac.mtu = 0B # = 0B -> no fragmentation, passed up by I/F
*.node**.mac.numSlots = (${NM})+1 # +1 for the uplink slot
# TODO: Adjust
*.node**.mac.queueLength = 999
*.node**.mac.startTime = 0s
*.node**.mac.slotPadding = ${SD}ms * 0.1
*.node**.mac.timeoutDuration = ${SD}ms * 0.2
*.nodeSlave**.mac.isSlave = true # Determines node behaviour mode
*.nodeSlave**.clusterId = ancestorIndex(2) % ${NM}
*.nodeMaster**.clusterId = ancestorIndex(2) 
**.mac.clusterId.param-record-as-scalar = true ## Effects all
*.node**.mac.slavesInCluster = ${SPM} # Used to let Master know how many messages to expect during uplink slot

# Radio
#
*.node**.radioType = "IdealRadio"
*.node**.radio.displayCommunicationRange = false
# --- --- Transmitter / Receiver
*.node**.radio.transmitter.bitrate = 2Mbps
*.node**.radio.transmitter.preambleDuration = 0s
*.node**.radio.transmitter.headerBitLength = 0b
*.node**.radio.transmitter.detectionRange = 999m
*.node**.radio.transmitter.interferenceRange = 0m
*.nodeSlave**.radio.transmitter.communicationRange = 75m
*.nodeMaster**.radio.transmitter.communicationRange = 225m
*.node**.radio.receiver.ignoreInterference = true

# Mobility
#
# --- Masters
*.nodeMaster[*].mobilityType = "CircleMobility"
*.node**.cx = 500m
*.node**.cy = 500m
*.node**.cz = 1.0m
*.nodeMaster**.r = 150m
*.nodeMaster**.startAngle = parentIndex() * (360deg/${NM})
# --- Slaves
*.nodeSlave[*].mobilityType = "CircleMobility"
*.nodeSlave**.r = 200m
*.nodeSlave**.startAngle = ((parentIndex() % ${NM})  * (360deg/${NM})) + (${SS} * floor(parentIndex() / ${NM})) - ((${SS} * (${SPM}-1)) * .5)

# Results
#
**.lo.**.scalar-recording = false
**.arp.**.scalar-recording = false
**.arp.**.vector-recording = false
**.udp.**.scalar-recording = false
**.udp.**.vector-recording = false
**.radio.**.scalar-recording = false
**.radio.**.vector-recording = false
**.radioMedium.**.scalar-recording = false
**.radioMedium.**.vector-recording = false

**.energyStorage.residualCapacity.vector-recording = true
**.udpApp[*].endToEndDelay.scalar-recording = true
**.udpApp[*].rcvdPk.vector-recording = true
**.udpApp[*].rcvdPk.scalar-recording = true
**.udpApp[*].rcvdPk.statistic-recording = true
**.udpApp[*].sentPk.vector-recording = true
**.udpApp[*].sentPk.scalar-recording = true
**.udpApp[*].throughput.scalar-recording = true
**.mac."MAC Access Delay".vector-recording = true
# Everything on
#**.statistic-recording = true
#**.scalar-recording = true
#**.vector-recording = true
#**.result-recording-modes = all

# Visualization
# TODO: Examine visualizer documentation further
#
#*.visualizer.physicalLinkVisualizer.packetNameFilter = "UDPData*"
#*.visualizer.dataLinkVisualizer.packetNameFilter = "UDPData*"
#*.visualizer.networkRouteVisualizer.packetNameFilter = "UDPData*"
#*.visualizer.mobilityVisualizer.displayMovementTrail = true

					#									#
					# 			GroundStation			#
					#									#

[Config GroundStation]
extends = Clusters
network = GroundStation

*.numGround = 1

# Obstacles
# TODO: Check further params
*.physicalEnvironment.config = xmldoc("walls.xml")
*.radioMedium.obstacleLossType = "IdealObstacleLoss"

**.aodv.activeRouteTimeout = ${ATT=3}s # D:3s
**.aodv.netDiameter = ${ND=3} # D:35 the maximum possible number of hops between two nodes in the network
#**.aodv.nodeTraversalTime = ${NTT= 0.114..0.116 step 0.00005}s
**.aodv.nodeTraversalTime = ${NTT=0.115}s

*.nodeGround**.udpApp[0].typename = "UDPSink"

**.udpApp[*].typename = "UDPBasicApp"
**.udpApp[*].destAddresses = "nodeGround[0]"

# Slots  0 .. NM-1
**.mac.numSlots = ${NM} + 2 # +1 for ground (acting like an extra master)

*.nodeGround**.mac.clusterId = ${NM} # 0..3 for masters 4 for ground 5 for slave uplink

*.nodeGround**.radio.transmitter.communicationRange = 75m

*.nodeGround**mobilityType = "CircleMobility"
*.nodeGround**.r = 85m
*.nodeGround**.startAngle = 0deg

					#											#
					#			OrbitingGroundStation			#
					#											#

[Config OrbitingGroundStation]
extends = GroundStation
sim-time-limit = 250s
**.udpApp[*].stopTime = 200s
**nodeMaster**.speed = 1.125mps
**nodeSlave**.speed = 1.5mps

					#									#
					#			EnergyModelling			#
					#									#

[Config EnergyModelling]
extends = GroundStation
#extends = OrbitingGroundStation

*.node**.energyStorageType = "IdealEnergyStorage"
*.node**.radio.energyConsumerType = "StateBasedEnergyConsumer"

*.node**.radio.energyConsumer.offPowerConsumption = 0mW
*.node**.radio.energyConsumer.sleepPowerConsumption = 1mW
*.node**.radio.energyConsumer.switchingPowerConsumption = 1mW

*.node**.radio.energyConsumer.receiverIdlePowerConsumption = 2mW
*.node**.radio.energyConsumer.receiverBusyPowerConsumption = 5mW
*.node**.radio.energyConsumer.receiverReceivingPowerConsumption = 10mW

*.node**.radio.energyConsumer.transmitterIdlePowerConsumption = 2mW
*.node**.radio.energyConsumer.transmitterTransmittingPowerConsumption = 100mW

[Config DemoData]
extends = EnergyModelling
sim-time-limit = 110s
**.udpApp[*].startTime = 10s
**.udpApp[*].stopTime = 110s

					#								#
					#			APSKRadio			#
					#								#

# Currently not allowing 'simultaneous' reception
[Config APSKRadio]
extends = EnergyModelling

*.radioMediumType = "APSKScalarRadioMedium"
*.radioMedium.backgroundNoise.power = -110dBm

# Issue not at the cache
*.radioMedium.mediumLimitCache.carrierFrequency = 2.412GHz 
*.radioMedium.mediumLimitCache.maxTransmissionDuration= 999s
*.radioMedium.mediumLimitCache.minInterferenceTime = 999s

*.radioMedium.propagationType = "ConstantTimePropagation"
*.radioMedium**.propagationTime = 0s

*.node**.radioType = "APSKScalarRadio" 

*.node**.radio.carrierFrequency = 2.412GHz 
*.node**.radio.bandwidth = 2MHz 

*.node**.radio.transmitter.power = 2mW 
*.node**.radio.transmitter.preambleDuration = 0s 
*.node**.radio.transmitter.headerBitLength = 0b 
*.node**.radio.transmitter.modulation = "BPSK"

*.node**.radio.receiver.sensitivity = -85dBm 
*.node**.radio.receiver.energyDetection = -85dBm 
*.node**.radio.receiver.snirThreshold = 4dB



