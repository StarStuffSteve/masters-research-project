[Config OneCluster]
# TODO: Clean up restatement of default values
network = Base
#sim-time-limit = 500s

#
# Random Numbers
#
num-rngs = 3
**.mobility.rng-0 = 1
**.wlan[*].mac.rng-0 = 2

#
# Clusters
#
# TODO: Make better use of iteration variables
*.numMasters = ${NM=1}
*.numSlaves = ${NS=(${NM})*2}
*.slavesPerMaster = ${SPM=(${NS}/${NM})}

#
# Medium
#
*.radioMediumType = "IdealRadioMedium"
# ... ... *sigh*
*.radioMedium.mediumLimitCache.maxTransmissionDuration= 999s
*.radioMedium.mediumLimitCache.minInterferenceTime = 999s
#*.radioMedium.radioModeFilter = true # Do not send to radios which are no in recv or trancv
*.radioMedium.propagationType = "ConstantTimePropagation" # Doesn't affect transmission durations which is bits/bitrate ...
*.radioMedium.**.propagationTime = 0s

#
# Host
#
#*.nodeMaster[*].hasStatus = false # Lifecycle
#*.nodeMaster[*].energyStorageType = ""
#*.nodeMaster[*].energyGeneratorType = ""
*.nodeMaster[*].numUdpApps = 1
*.nodeSlave[*].numUdpApps = 1
# TODO: Explore AODV example/code

#
# Application
#
# https://omnetpp.org/doc/inet/api-current/neddoc/index.html?p=inet.applications.udpapp.UDPSink.html
#
# --- Master 0
*.nodeMaster[0].udpApp[0].typename = "UDPSink"
*.nodeMaster[0].udpApp[0].localPort = 5000

*.nodeSlave[*].udpApp[0].typename = "UDPBasicApp"
*.nodeSlave[*].udpApp[0].destAddresses = "nodeMaster[0]"
*.nodeSlave[*].udpApp[0].packetName = "UDPDataSlave"
*.nodeSlave[*].udpApp[0].destPort = 5000
*.nodeSlave[*].udpApp[0].messageLength = exponential(128B)
*.nodeSlave[*].udpApp[0].startTime = 0s
*.nodeSlave[*].udpApp[0].sendInterval = 100ms*(${NM} + 1) # One every frame
#*.nodeSlave[*].udpApp[0].stopTime = # Default -1 (forever)
#*.nodeSlave[*].udpApp[0].localPort = # Default -1
#*.nodeSlave[*].udpApp[0].localAddress = # ""
#*.nodeSlave[*].udpApp[0].timeToLive = # Default -1 (forever)

#
# Network
#
**.networkLayer.arpType = "GlobalARP"
#**.configurator.config = xml("<config><interface hosts='**' address='10.0.0.x' netmask='255.255.255.0'/><autoroute metric='errorRate'/></config>")
#**.configurator.optimizeRoutes = false
#**.routingTable.netmaskRoutes = ""

#*.node**.forwarding = true # Redundant with AODV
*.configurator.addStaticRoutes = false # Important for AODV

#
# NIC
#
*.node*[*].wlan[*].typename = "WirelessNic"

# --- MAC
# TODO: Trim parameters
*.node*[*].wlan[*].macType = "CubeMacLayer"
*.node*[*].wlan[*].mac.address = "auto"
*.node*[*].wlan[*].mac.bitrate = 2Mbps # TODO: What is bitrate inheritence pattern?
*.node*[*].wlan[*].mac.slotDuration = 100ms
*.node*[*].wlan[*].mac.headerLength = 10B
*.node*[*].wlan[*].mac.mtu = 0B # = 0B -> no fragmentation, passed up by I/F
*.node*[*].wlan[*].mac.numSlots = (${NM})+1 # +1 for the uplink slot
*.node*[*].wlan[*].mac.queueLength = 50 # TODO: Should be some function of slot length and packet generation

*.node*[*].wlan[*].mac.startTime = 0s
*.node*[*].wlan[*].mac.timeoutDuration = 20ms

*.nodeSlave[*].wlan[*].mac.isSlave = true # Determines node behaviour mode
*.nodeSlave[0].wlan[*].mac.slaveId = 0 # Used to determine small offset in uplink slot --- Must be unique for now
*.nodeSlave[1].wlan[*].mac.slaveId = 1 
*.nodeMaster[0].wlan[*].mac.masterId = 0 # Used to assign static slots within frame --- Must be unique
*.nodeMaster[0].wlan[*].mac.clusterId = 0 # Could be used to stop slaves from receiving from masters outside of cluster

*.node*[*].wlan[*].mac.slavesInCluster = ${SPM} # Used to let Master know how many control messages to expect in uplink slot
**.slaveOffset = 10ms # Used for testing collision hypothesis

# TODO: Try this out again
 # How does this affect the transmitter bitrate?
#*.node*[*].wlan[*].mac.radioModule = "^.radio" # Path to radio module

# --- Radio
#
# https://omnetpp.org/doc/inet/api-current/neddoc/inet.physicallayer.common.packetlevel.Radio.html
# 
*.node*[*].wlan[*].radioType = "IdealRadio"
*.node*[*].wlan[*].radio.displayCommunicationRange = true

# --- Radio: Transmitter / Receiver
*.node*[*].wlan[*].radio.transmitter.bitrate = 2Mbps
*.node*[*].wlan[*].radio.transmitter.preambleDuration = 0s
*.node*[*].wlan[*].radio.transmitter.headerBitLength = 0b
*.node*[*].wlan[*].radio.transmitter.detectionRange = 999m
*.node*[*].wlan[*].radio.transmitter.interferenceRange = 0m
*.nodeSlave[*].wlan[*].radio.transmitter.communicationRange = 100m
*.nodeMaster[*].wlan[*].radio.transmitter.communicationRange = 235m

*.node*[*].wlan[*].radio.receiver.ignoreInterference = true

#
# Mobility
#
*.nodeMaster[*].mobilityType = "CircleMobility"
*.nodeMaster[*].**.cx = 500m
*.nodeMaster[*].**.cy = 250m
*.nodeMaster[*].**.cz = 0m
*.nodeMaster[*].**.r = 100m
*.nodeMaster[*].**.startAngle = parentIndex() * (360deg/${NM})

*.nodeSlave[*].mobilityType = "CircleMobility"
*.nodeSlave[*].**.cx = 500m
*.nodeSlave[*].**.cy = 250m
*.nodeSlave[*].**.cz = 0m
*.nodeSlave[*].**.r = 150m
*.nodeSlave[0].**.startAngle = (parentIndex() * (360deg/${NM})) + 10deg
*.nodeSlave[1].**.startAngle = (parentIndex() * (360deg/${NM})) - 10deg

#
# Visualization
#
# TODO: Examine visualizer documentation
*.visualizer.physicalLinkVisualizer.packetNameFilter = "UDPData*"
*.visualizer.dataLinkVisualizer.packetNameFilter = "UDPData*"
*.visualizer.networkRouteVisualizer.packetNameFilter = "UDPData*"
#*.visualizer.mobilityVisualizer.displayMovementTrail = true

[Config SlaveCollisionsIdealRadio]
extends = OneCluster
**.slaveOffset = 0.1ms

#
#
#

[Config TwoClusters]
# TODO: Seperate ini files
# Have to redefine and reuse all iteration variables
extends = OneCluster

*.numMasters = ${NMT=2}
*.numSlaves = ${NST=(${NMT})*2}
*.slavesPerMaster = ${SPMT=(${NST}/${NMT})}

*.node*[*].wlan[*].mac.numSlots = (${NMT})+1 # +1 for the uplink slot
*.node*[*].wlan[*].mac.slavesInCluster = ${SPMT} # Used to let Master know how many control messages to expect in uplink slot

# --- Works with both Master 1 as Sink and App
*.nodeMaster[1].udpApp[0].typename = "UDPSink"
*.nodeMaster[1].udpApp[0].localPort = 5000

#*.nodeMaster[1].udpApp[0].typename = "UDPBasicApp"
#*.nodeMaster[1].udpApp[0].destAddresses = "nodeMaster[0]"
#*.nodeMaster[1].udpApp[0].packetName = "UDPDataMaster"
#*.nodeMaster[1].udpApp[0].destPort = 5000
#*.nodeMaster[1].udpApp[0].messageLength = exponential(128B)
#*.nodeMaster[1].udpApp[0].startTime = 0s
#*.nodeMaster[1].udpApp[0].sendInterval = 100ms*(${NMT} + 1) # One every frame

*.nodeSlave[*].udpApp[0].sendInterval = 100ms*(${NM} + 1) # One every frame

*.nodeSlave[0].wlan[*].mac.slaveId = 0 
*.nodeSlave[1].wlan[*].mac.slaveId = 0 
*.nodeSlave[2].wlan[*].mac.slaveId = 1 
*.nodeSlave[3].wlan[*].mac.slaveId = 1 

*.nodeSlave[0].wlan[*].mac.clusterId = 0 
*.nodeSlave[1].wlan[*].mac.clusterId = 1
*.nodeSlave[2].wlan[*].mac.clusterId = 0 
*.nodeSlave[3].wlan[*].mac.clusterId = 1

*.nodeMaster[0].wlan[*].mac.masterId = 0 
*.nodeMaster[1].wlan[*].mac.masterId = 1

*.nodeMaster[0].wlan[*].mac.clusterId = 0 
*.nodeMaster[1].wlan[*].mac.clusterId = 1 

*.nodeMaster[*].**.startAngle = parentIndex() * (360deg/${NMT})
*.nodeSlave[..1].**.startAngle = (parentIndex() * (360deg/${NMT})) + 10deg
*.nodeSlave[2..].**.startAngle = (parentIndex() * (360deg/${NMT})) - 10deg

[Config TwoClustersMoving]
extends = TwoClusters
**nodeMaster**.speed = 10mps
**nodeSlave**.speed = 15mps

#
#
#

[Config APSKRadio]
extends = OneCluster

*.radioMediumType = "APSKScalarRadioMedium"
*.radioMedium.backgroundNoise.power = -110dBm 
*.radioMedium.mediumLimitCache.carrierFrequency = 2GHz 

*.node*[*].wlan[*].radioType = "APSKScalarRadio" 
# Seem to only want to work with 802.11
#*.node*[*].wlan[0].radio.transmitterType = "APSKLayeredTransmitter"
#*.node*[*].wlan[0].radio.receiverType = "APSKLayeredReceiver"

*.node*[*].wlan[0].radio.carrierFrequency = 2.412GHz 
*.node*[*].wlan[0].radio.bandwidth = 2MHz 

*.node*[*].wlan[*].radio.transmitter.power = 2mW 
*.node*[*].wlan[*].radio.transmitter.preambleDuration = 0s 
*.node*[*].wlan[*].radio.transmitter.headerBitLength = 100b 
*.node*[*].wlan[*].radio.transmitter.modulation = "BPSK"

*.node*[*].wlan[*].radio.receiver.sensitivity = -85dBm 
*.node*[*].wlan[*].radio.receiver.energyDetection = -85dBm 
*.node*[*].wlan[*].radio.receiver.snirThreshold = 4dB 

[Config SlaveCollisionsAPSKRadio]
extends = APSKRadio
**.slaveOffset = 0.1ms

#
#
#

[Config EnergyModelling]
extends = APSKRadio

*.node*[*].energyStorageType = "IdealEnergyStorage"
*.node*[*].wlan[0].radio.energyConsumerType = "StateBasedEnergyConsumer"

*.node*[*].wlan[0].radio.energyConsumer.offPowerConsumption = 0mW
*.node*[*].wlan[0].radio.energyConsumer.sleepPowerConsumption = 1mW
*.node*[*].wlan[0].radio.energyConsumer.switchingPowerConsumption = 1mW

*.node*[*].wlan[0].radio.energyConsumer.receiverIdlePowerConsumption = 2mW
*.node*[*].wlan[0].radio.energyConsumer.receiverBusyPowerConsumption = 5mW
*.node*[*].wlan[0].radio.energyConsumer.receiverReceivingPowerConsumption = 10mW

*.node*[*].wlan[0].radio.energyConsumer transmitterIdlePowerConsumption = 2mW
*.node*[*].wlan[0].radio.energyConsumer.transmitterTransmittingPowerConsumption = 100mW


