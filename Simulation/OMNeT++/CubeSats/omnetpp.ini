
#								#
# 			Clusters			#
#								#

[Config Clusters]
# TODO: Seperate ini files
network = Base
sim-time-limit = 200s
#sim-time-limit.param-record-as-scalar = true

# TODO: Multiple config runs leading to statistical analysis
#repeat = 0
#seed-set = ${runnumber} # this is the default

# Random Numbers
#
num-rngs = 3
**.mobility.rng-0 = 1
**.wlan[*].mac.rng-0 = 2

# Cluster Numbers
#
#*.numMasters = ${NM=4..6}
*.numMasters = ${NM=4}
#*.slavesPerMaster = ${SPM=1..3}
*.slavesPerMaster = ${SPM=2}
*.numSlaves = ${NS=(${NM})*(${SPM})}
*.slaveSeperation = ${SS=10deg}

# Network & Routing
#
# IPv4NetworkLayer
**.networkLayer.arpType = "GlobalARP"
**.networkLayer.proxyARP = true
# IPv4NetworkLayer -> IPv4NodeConfigurator
#**.configurator.addStaticRoutes = true
#**.configurator.configureRoutingTable = true
## IPv4NetworkLayer -> IPv4
#**.networkLayer.ip.procDelay = 0s
#**.networkLayer.ip.timeToLive = 32
#**.networkLayer.ip.multicastTimeToLive = 32 
#**.networkLayer.ip.fragmentTimeout = 60s
#**.networkLayer.ip.forceBroadcast = false
#**.networkLayer.ip.useProxyARP = true
## IPv4RoutingTable
#**.routingTable.routerId = "auto"
#**.routingTable.netmaskRoutes = "*"
#**.routingTable.forwarding = true
#**.routingTable.multicastForwarding = false
#**.routingTable.routingFile = ""

# Medium
#
*.radioMediumType = "IdealRadioMedium"
*.radioMedium[*].rangeFilter = "communicationRange"
#*.radioMedium[*].radioModeFilter = true
#*.radioMedium[*].listeningFilter = true
*.radioMedium[*].mediumLimitCache.maxTransmissionDuration= 999s
*.radioMedium[*].mediumLimitCache.minInterferenceTime = 999s
*.radioMedium[*].propagationType = "ConstantTimePropagation" # Doesn't affect transmission durations which is bits/bitrate
*.radioMedium[*].**.propagationTime = 0s

# Applications
#
*.node**.numUdpApps = 1
*.nodeMaster[0].udpApp[*].typename = "UDPSink"
*.node**.udpApp[*].typename = "UDPBasicApp" # The rest

# --- Sink
**.udpApp[*].localPort = 5000

# --- App
**.udpApp[*].destAddresses = "nodeMaster[0]"
**.udpApp[*].packetName = "UDP" + substringBefore(substringAfter(fullPath(), ".node"), ".udp")
**.udpApp[*].destPort = 5000
#**.udpApp[*].messageLength = ${ML = 32, 64, 128, 256}B # DemoData
**.udpApp[*].messageLength = ${ML = 128}B
**.udpApp[*].messageLength.param-record-as-scalar = true
#*.dummySend = ${SI=0.25, 0.5, 1} # DemoData
#**.sendInterval = truncnormal(${SI}s, (${SI} * 0.1s)) # DemoData
**.sendInterval = 10s
**.udpApp[*].startTime = 0s 
**.udpApp[*].stopTime = 100s
**.udpApp[*].stopTime.param-record-as-scalar = true

# NIC --- S2S---
#
*.node**.wlan[0].typename = "WirelessNic"
# MAC
#
*.node**.wlan[0].macType = "CubeMacLayer"
*.node**.wlan[0].mac.address = "auto"
*.node**.wlan[0].mac.bitrate = 2Mbps
#*.node**.wlan[0].mac.slotDuration = ${SD = 0.01, 0.025, 0.05, 0.075, 0.1}s
*.node**.wlan[0].mac.slotDuration = ${SD = 0.1}s
**.mac.slotDuration.param-record-as-scalar = true
*.node**.wlan[0].mac.headerLength = 10B
*.node**.wlan[0].mac.mtu = 0B # = 0B -> no fragmentation, passed up by I/F
*.node**.wlan[0].mac.numSlots = (${NM})+1 # +1 for the uplink slot
# TODO: Adjust
*.node**.wlan[0].mac.queueLength = 999
*.node**.wlan[0].mac.startTime = 0s
*.node**.wlan[0].mac.slotPadding = ${SD}s * 0.1
*.node**.wlan[0].mac.timeoutDuration = ${SD}s * 0.2
*.nodeSlave**.wlan[0].mac.isSlave = true # Determines node behaviour mode
*.nodeSlave**.wlan[0].mac.clusterId = ancestorIndex(2) % ${NM}
*.nodeMaster**.wlan[0].mac.clusterId = ancestorIndex(2) 
**.mac.clusterId.param-record-as-scalar = true ## Effects all
*.node**.wlan[0].mac.slavesInCluster = ${SPM} # Used to let Master know how many messages to expect during uplink slot

# TODO: Investiage channels
# Radio 
#
*.node**.wlan[0].radioType = "IdealRadio"
# TODO: May be messing up obstacle ...
*.node**.wlan[0].radio.radioMediumModule = "radioMedium[0]"
*.node**.wlan[0].radio.displayCommunicationRange = true
# --- --- Transmitter / Receiver
*.node**.wlan[0].radio.transmitter.bitrate = 2Mbps
*.node**.wlan[0].radio.transmitter.preambleDuration = 0s
*.node**.wlan[0].radio.transmitter.headerBitLength = 0b
*.node**.wlan[0].radio.transmitter.detectionRange = 999m
*.node**.wlan[0].radio.transmitter.interferenceRange = 0m
*.nodeSlave**.wlan[0].radio.transmitter.communicationRange = 75m
*.nodeMaster**.wlan[0].radio.transmitter.communicationRange = 225m
*.node**.wlan[0].radio.receiver.ignoreInterference = true

# Mobility
#
# --- Masters
*.nodeMaster[*].mobilityType = "CircleMobility"
*.node**.cx = 500m
*.node**.cy = 500m
*.node**.cz = 0.0m
*.nodeMaster**.r = 150m
*.nodeMaster**.startAngle = parentIndex() * (360deg/${NM})
# --- Slaves
*.nodeSlave[*].mobilityType = "CircleMobility"
*.nodeSlave**.r = 200m
*.nodeSlave**.startAngle = ((parentIndex() % ${NM})  * (360deg/${NM})) + (${SS} * floor(parentIndex() / ${NM})) - ((${SS} * (${SPM}-1)) * .5)

# Results
#
**.lo.**.scalar-recording = false
**.arp.**.scalar-recording = false
**.arp.**.vector-recording = false
**.udp.**.scalar-recording = false
**.udp.**.vector-recording = false
**.radio.**.scalar-recording = false
**.radio.**.vector-recording = false
**.radioMedium.**.scalar-recording = false
**.radioMedium.**.vector-recording = false

**.energyStorage.residualCapacity.vector-recording = true
**.udpApp[*].endToEndDelay.scalar-recording = true
**.udpApp[*].rcvdPk.vector-recording = true
**.udpApp[*].rcvdPk.scalar-recording = true
**.udpApp[*].rcvdPk.statistic-recording = true
**.udpApp[*].sentPk.vector-recording = true
**.udpApp[*].sentPk.scalar-recording = true
**.udpApp[*].throughput.scalar-recording = true
**.mac."MAC Access Delay".vector-recording = true
# Everything on
#**.statistic-recording = true
#**.scalar-recording = true
#**.vector-recording = true
#**.result-recording-modes = all

# Visualization
# TODO: Examine visualizer documentation further
#
#*.visualizer.physicalLinkVisualizer.packetNameFilter = "UDPData*"
#*.visualizer.dataLinkVisualizer.packetNameFilter = "UDP*"
*.visualizer.**.packetNameFilter = "RR*"
#*.visualizer.networkRouteVisualizer.packetNameFilter = "UDPData*"
#*.visualizer.mobilityVisualizer.displayMovementTrail = true

					#							#
					# 			DYMO			#
					#							#

[Config DYMO] 
extends = Clusters

**.configurator.config = xmldoc("DYMOConfig.xml")
**.configurator.assignDisjunctSubnetAddresses = false
**.configurator.addStaticRoutes = false
**.configurator.addSubnetRoutes = false
**.configurator.addDefaultRoutes = false
**.configurator.optimizeRoutes = false
**.configurator.dumpAddresses = true
**.configurator.dumpRoutes = true

#**.udpApp[0].localPort = 100
#**.udpApp[0].destPort = 100
**.udpApp[*].joinLocalMulticastGroups = true

**.multicastForwarding = false
**.networkLayer.igmp.queryInterval = 60s

**.igmpType = "IGMPv2"
#**.igmpType = "IGMPv3"

*.hostType = "DYMORouter"

#wlan[*].mgmtType = default("Ieee80211MgmtAdhoc");
#string dymoType = default("DYMO");

# Router is always its own client
**.dymo.clientAddresses = "" # "10.0.0.0/24 10.10.0.0"  # 1. DYMO parameter group
#**.dymo.interfaces =  # "*" string DEFAULT_METRIC_TYPE = default("HOP_COUNT"); 
**.dymo.activeInterval = 5s # 5s 2. DYMO parameter group

# NB: Equivalent to broadcasting RREP back to originators
**.dymo.useMulticastRREP = false
**.dymo.maxIdleTime = 200s # 200s MAX_IDLETIME
# Used to calculate default route expiration times
**.dymo.maxSequenceNumberLifetime = 300s # 300s MAX_SEQNUM_LIFETIME

# "not received within RREQ_WAIT_TIME, RREQ_Gen may retry the Route Discovery by generating another RREQ."
**.dymo.routeRREQWaitTime =	10s # 2s ROUTE_RREQ_WAIT_TIME

**.dymo.rreqHolddownTime = 10s # 10s double UNICAST_MESSAGE_SENT_TIMEOUT @unit("s") = default(1s);

# Param sweep: Only works for 4 and 5. Only getting 60 packets to ground in either case.
**.dymo.maxHopCount	= 20 # 20 3. DYMO parameter group #

**.dymo.discoveryAttemptsMax = 3 # 3 string MAX_METRIC = default(""); double MAXTIME;
**.dymo.appendInformation = true # true 4. DYMO parameter group - *See DYMO.msg: AddressBlock addedNode[];
**.dymo.bufferSizePackets = -1 # -1 BUFFER_SIZE_PACKETS
**.dymo.bufferSizeBytes	= -1B # -1B BUFFER_SIZE_BYTES double CONTROL_TRAFFIC_LIMIT
**.dymo.maxJitter = 10ms # 10ms DYMO extension parameters - *Sampling uniform to get send delay for RteMsgs
**.dymo.sendIntermediateRREP = true # true
**.dymo.minHopLimit	= 5	# 5
**.dymo.maxHopLimit	= 10 # 10

					#									#
					# 			GroundStation			#
					#									#

[Config GroundStation]
#extends = Clusters
extends = DYMO
network = GroundStation
result-dir = ./results/ground_testing/

*.numGround = 1

# Obstacles
# TODO: Check further params
*.physicalEnvironment.config = xmldoc("walls.xml")
*.radioMedium[*].obstacleLossType = "IdealObstacleLoss"

*.nodeGround**.udpApp[0].typename = "UDPSink"

**.udpApp[*].typename = "UDPBasicApp"
**.udpApp[*].destAddresses = "nodeGround[0]"

# Slots  0 .. NM-1
**.mac.numSlots = ${NM} + 2 # +1 for ground (acting like an extra master)

*.nodeGround**.mac.clusterId = ${NM} # 0..3 for masters 4 for ground 5 for slave uplink

*.nodeGround**.radio.transmitter.communicationRange = 75m

*.nodeGround**mobilityType = "CircleMobility"
*.nodeGround**.r = 85m
*.nodeGround**.startAngle = 0deg

					#											#
					#			OrbitingGroundStation			#
					#											#

# TODO: AODV should use hello messages while nodes orbit
[Config OrbitingGroundStation]
extends = GroundStation
sim-time-limit = 250s
**.udpApp[*].stopTime = 200s
**nodeMaster**.speed = 1.125mps * 2
**nodeSlave**.speed = 1.5mps * 2

					#								#
					# 			MultiNIC			#
					#								#
#
# Work In Progress
#
[Config MultiNIC]
extends = DYMO
result-dir = ./results/multi_testing/

*.nodeSlave**numRadios = 2
*.nodeMaster**numRadios = 2

# NIC --- S2G ---
#
*.node**.wlan[1].typename = "IdealWirelessNic"
# MAC
#
#*.node**.wlan[1].macType = "IdealMac"
*.node**.wlan[1].address = "auto"
*.node**.wlan[1].bitrate = 2Mbps
*.node**.wlan[1].mtu = 0B # = 0B -> no fragmentation, passed up by I/F
*.node**.wlan[1].headerLength = 10B
*.node**.wlan[1].promiscuous = false
*.node**.wlan[1].fullDuplex = false
*.node**.wlan[1].useAck = false
*.node**.wlan[1].ackTimeout = 100ms

# Radio
# 
*.node**.wlan[1].radioType = "IdealRadio"
*.node**.wlan[1].radio.radioMediumModule = "radioMedium[1]"
*.node**.wlan[1].radio.displayCommunicationRange = true
# --- --- Transmitter / Receiver
*.node**.wlan[1].radio.transmitter.bitrate = 2kbps # mtu will be important
*.node**.wlan[1].radio.transmitter.preambleDuration = 0s
*.node**.wlan[1].radio.transmitter.headerBitLength = 0b
*.node**.wlan[1].radio.transmitter.detectionRange = 999m
*.node**.wlan[1].radio.transmitter.interferenceRange = 0m
*.nodeSlave**.wlan[1].radio.transmitter.communicationRange = 75m
*.nodeMaster**.wlan[1].radio.transmitter.communicationRange = 225m
*.node**.wlan[1].radio.receiver.ignoreInterference = true

					#									#
					#			EnergyModelling			#
					#									#

[Config EnergyModelling]
extends = GroundStation
#extends = OrbitingGroundStation

*.node**.energyStorageType = "IdealEnergyStorage"
*.node**.radio.energyConsumerType = "StateBasedEnergyConsumer"

*.node**.radio.energyConsumer.offPowerConsumption = 0mW
*.node**.radio.energyConsumer.sleepPowerConsumption = 1mW
*.node**.radio.energyConsumer.switchingPowerConsumption = 1mW

*.node**.radio.energyConsumer.receiverIdlePowerConsumption = 2mW
*.node**.radio.energyConsumer.receiverBusyPowerConsumption = 5mW
*.node**.radio.energyConsumer.receiverReceivingPowerConsumption = 10mW

*.node**.radio.energyConsumer.transmitterIdlePowerConsumption = 2mW
*.node**.radio.energyConsumer.transmitterTransmittingPowerConsumption = 100mW

[Config DemoData]
extends = EnergyModelling
sim-time-limit = 110s
**.udpApp[*].startTime = 10s
**.udpApp[*].stopTime = 110s

					#								#
					#			NarrowBand			#
					#								#

[Config NarrowBand]
extends = EnergyModelling

*.node**.radioType = "NarrowbandRadioBase"

*.node**.radio.antennaType = "IsotropicAntenna"
*.node**.radio.transmitterType = "NarrowbandTransmitterBase"
*.node**.radio.receiverType = "NarrowbandReceiverBase"

*.node**.radio.carrierFrequency = 2.412GHz 
*.node**.radio.bandwidth = 4MHz 

*.node**.radio.transmitter.preambleDuration = 0s
*.node**.radio.transmitter.headerBitLength = 0b
*.node**.radio.transmitter.bitrate = 2Mbps
*.node**.radio.transmitter.power = 2mW
#*.node**.radio.transmitter.carrierFrequency = 2.412GHz 
#*.node**.radio.transmitter.bandwidth = 4MHz 
*.node**.radio.transmitter.modulation = "BPSK"

*.node**.radio.receiver.energyDetection = -85dBm 
*.node**.radio.receiver.sensitivity = -85dBm 
*.node**.radio.receiver.snirThreshold = 4dB
#*.node**.radio.receiver.carrierFrequency = 2.412GHz
#*.node**.radio.receiver.bandwidth = 4MHz 
*.node**.radio.receiver.errorModelType = "ErrorModelBase"
*.node**.radio.receiver.modulation = "BPSK"

					#								#
					#			APSKRadio			#
					#								#

# Currently not allowing 'simultaneous' reception
[Config APSKRadio]
extends = EnergyModelling

# Apply to all media

*.radioMediumType = "APSKScalarRadioMedium"
*.radioMedium.backgroundNoise.power = -110dBm

# Issue not at the cache
*.radioMedium.mediumLimitCache.carrierFrequency = 2.412GHz 
*.radioMedium.mediumLimitCache.maxTransmissionDuration= 999s
*.radioMedium.mediumLimitCache.minInterferenceTime = 999s

*.radioMedium.propagationType = "ConstantTimePropagation"
*.radioMedium**.propagationTime = 0s

*.node**.radioType = "APSKScalarRadio" 

*.node**.radio.carrierFrequency = 2.412GHz 
*.node**.radio.bandwidth = 2MHz 

*.node**.radio.transmitter.power = 2mW 
*.node**.radio.transmitter.preambleDuration = 0s 
*.node**.radio.transmitter.headerBitLength = 0b 
*.node**.radio.transmitter.modulation = "BPSK"

*.node**.radio.receiver.sensitivity = -85dBm 
*.node**.radio.receiver.energyDetection = -85dBm 
*.node**.radio.receiver.snirThreshold = 4dB



