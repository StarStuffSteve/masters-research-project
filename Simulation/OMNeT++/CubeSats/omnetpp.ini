
#								#
# 			Clusters			#
#								#

# TODO: Seperate ini files
[Config Clusters]
network = Base
#sim-time-limit = 5s
#sim-time-limit = 20s
#sim-time-limit.param-record-as-scalar = true

# TODO: Multiple run repitions
#repeat = 0
#seed-set = ${runnumber} # this is the default

*.roleOracle.updateFrequency = 2s

# Random Numbers
#
num-rngs = 3
**.mobility.rng-0 = 1
**.wlan[*].mac.rng-0 = 2

# Cluster Configuration
#
*.numMasters = ${NM=4}
*.slavesPerMaster = ${SPM=2}
*.numSlaves = ${NS=(${NM})*(${SPM})}
*.slaveSeperation = ${SS=10deg}

# Network & Routing
#
# IPv4NetworkLayer
**.networkLayer.arpType = "GlobalARP"
**.networkLayer.proxyARP = true

# Medium
#
*.radioMediumType = "IdealRadioMedium"
*.radioMedium[*].rangeFilter = "communicationRange"
#*.radioMedium[*].radioModeFilter = true
#*.radioMedium[*].listeningFilter = true
*.radioMedium[*].mediumLimitCache.maxTransmissionDuration= 999s
*.radioMedium[*].mediumLimitCache.minInterferenceTime = 999s
*.radioMedium[*].propagationType = "ConstantTimePropagation" # Doesn't affect transmission durations which is bits/bitrate
*.radioMedium[*].**.propagationTime = 0s

# Applications
#
*.node**.numUdpApps = 1
*.nodeMaster[0].udpApp[*].typename = "UDPSink"
*.node**.udpApp[*].typename = "UDPBasicApp" # All nodes which are not Master[0]
# --- Sink
**.udpApp[*].localPort = 5000
# --- BasicApp
**.udpApp[*].destAddresses = "nodeMaster[0]"
**.udpApp[*].packetName = "UDP" + substringBefore(substringAfter(fullPath(), ".node"), ".udp")
**.udpApp[*].destPort = 5000
**.udpApp[*].messageLength = ${ML = 128}B
**.udpApp[*].messageLength.param-record-as-scalar = true
#*.nodeSlave**.udpApp[*].sendInterval = 3s
#*.nodeMaster**.udpApp[*].sendInterval = 2s
**.udpApp[*].sendInterval = 1s
**.udpApp[*].startTime = 0s
#*.nodeSlave**.udpApp[*].stopTime = 4s
#*.nodeMaster**.udpApp[*].stopTime = 4s
#**.udpApp[*].stopTime = 10s

# NIC --- S2S---
#
*.node**.wlan[0].typename = "WirelessNic"
# --- MAC
*.node**.wlan[0].macType = "CubeMacLayer"
*.node**.wlan[0].mac.address = "auto"
*.node**.wlan[0].mac.bitrate = 2Mbps
*.node**.wlan[0].mac.slotDuration = ${SD = 0.1}s
*.node**.wlan[0].mac.slotDuration.param-record-as-scalar = true
*.node**.wlan[0].mac.headerLength = 1B # Cannot be 0b
*.node**.wlan[0].mac.mtu = 0B # = 0B -> no fragmentation, passed up by I/F
*.node**.wlan[0].mac.numSlots = (${NM})+1 # +1 for the uplink slot
*.node**.wlan[0].mac.queueLength = 999
*.node**.wlan[0].mac.startTime = 0s
*.node**.wlan[0].mac.slotPadding = ${SD}s * 0.1
*.node**.wlan[0].mac.timeoutDuration = ${SD}s * 0.2
*.nodeSlave**.wlan[0].mac.isSlave = true # Determines node behaviour mode
*.nodeSlave**.wlan[0].mac.clusterId = ancestorIndex(2) % ${NM}
*.nodeMaster**.wlan[0].mac.clusterId = ancestorIndex(2) 
*.node**.wlan[0].mac.clusterId.param-record-as-scalar = true # Effects all
*.node**.wlan[0].mac.slavesInCluster = ${SPM} # Used to let Master know how many messages to expect during uplink slot

# Radio 
#
*.node**.wlan[0].radioType = "IdealRadio"
*.node**.wlan[0].radio.radioMediumModule = "radioMedium[0]"
*.node**.wlan[0].radio.displayCommunicationRange = true
# --- Transmitter / Receiver
*.node**.wlan[0].radio.transmitter.bitrate = 2Mbps
*.node**.wlan[0].radio.transmitter.preambleDuration = 0s
*.node**.wlan[0].radio.transmitter.headerBitLength = 0b
*.node**.wlan[0].radio.transmitter.detectionRange = 999m
*.node**.wlan[0].radio.transmitter.interferenceRange = 0m
*.nodeSlave**.wlan[0].radio.transmitter.communicationRange = 75m
*.nodeMaster**.wlan[0].radio.transmitter.communicationRange = 225m
*.node**.wlan[0].radio.receiver.ignoreInterference = true

# Mobility
#
*.nodeMaster[*].mobilityType = "CircleMobility"
*.nodeSlave[*].mobilityType = "CircleMobility"
*.node**.cx = 500m
*.node**.cy = 500m
*.node**.cz = 10m
*.nodeMaster**.r = 150m
*.nodeMaster**.startAngle = parentIndex() * (360deg/${NM})
*.nodeSlave**.r = 200m
*.nodeSlave**.startAngle = ((parentIndex() % ${NM})  * (360deg/${NM})) + (${SS} * floor(parentIndex() / ${NM})) - ((${SS} * (${SPM}-1)) * .5)

# Results
#
**.lo.**.scalar-recording = false
**.arp.**.scalar-recording = false
**.arp.**.vector-recording = false
**.udp.**.scalar-recording = false
**.udp.**.vector-recording = false
**.radio.**.scalar-recording = false
**.radio.**.vector-recording = false
**.radioMedium.**.scalar-recording = false
**.radioMedium.**.vector-recording = false

**.energyStorage.residualCapacity.vector-recording = true
**.udpApp[*].endToEndDelay.scalar-recording = true
**.udpApp[*].rcvdPk.vector-recording = true
**.udpApp[*].rcvdPk.scalar-recording = true
**.udpApp[*].rcvdPk.statistic-recording = true
**.udpApp[*].sentPk.vector-recording = true
**.udpApp[*].sentPk.scalar-recording = true
**.udpApp[*].throughput.scalar-recording = true
**.mac."MAC Access Delay".vector-recording = true
# Everything on
#**.statistic-recording = true
#**.scalar-recording = true
#**.vector-recording = true
#**.result-recording-modes = all

# Visualization - Multiple media messes up medium visualization
# TODO: Examine visualizer documentation further
#
*.visualizer.**.packetNameFilter = "UDP*"
#*.visualizer.**.packetNameFilter = "RR*"
#*.visualizer.mobilityVisualizer.displayMovementTrail = true

					#							#
					# 			DYMO			#
					#							#

[Config DYMO] 
extends = Clusters

*.hostType = "DYMORouter"

**.configurator.config = xmldoc("DYMOConfig.xml")
**.configurator.assignDisjunctSubnetAddresses = false
**.configurator.addStaticRoutes = false
**.configurator.addSubnetRoutes = false
**.configurator.addDefaultRoutes = false
**.configurator.optimizeRoutes = false
**.configurator.dumpAddresses = true
**.configurator.dumpRoutes = true

**.multicastForwarding = false # Multicast forwarding is handled by DYMO
**.networkLayer.igmp.queryInterval = 60s

**.dymo.clientAddresses = "" # Router is always its own client
#**.dymo.interfaces =  # "*" string DEFAULT_METRIC_TYPE = default("HOP_COUNT"); - TODO
**.dymo.activeInterval = 20s # 5s 2. DYMO parameter group
**.dymo.useMulticastRREP = false
**.dymo.maxIdleTime = 200s # 200s MAX_IDLETIME
**.dymo.maxSequenceNumberLifetime = 300s # Used to calculate default route expiration times
# "RREQ not received within RREQ_WAIT_TIME, RREQ_Gen may retry the Route Discovery by generating another RREQ."
**.dymo.routeRREQWaitTime =	10s # 2s ROUTE_RREQ_WAIT_TIME
**.dymo.rreqHolddownTime = 10s # 10s double UNICAST_MESSAGE_SENT_TIMEOUT @unit("s") = default(1s);
**.dymo.maxHopCount	= 20 # 20 3. DYMO parameter group #
**.dymo.discoveryAttemptsMax = 3 # 3 string MAX_METRIC = default(""); double MAXTIME;
**.dymo.appendInformation = true # true 4. DYMO parameter group - See DYMO.msg: AddressBlock addedNode[];
**.dymo.bufferSizePackets = -1 # -1 BUFFER_SIZE_PACKETS
**.dymo.bufferSizeBytes	= -1B # -1B BUFFER_SIZE_BYTES double CONTROL_TRAFFIC_LIMIT
**.dymo.maxJitter = 10ms # 10ms DYMO extension parameters - Sampling uniform to get send delay for RteMsgs
**.dymo.sendIntermediateRREP = true # true
**.dymo.minHopLimit	= 5	# 5
**.dymo.maxHopLimit	= 10 # 10

					#									#
					# 			GroundStation			#
					#									#

[Config GroundStation]
#extends = Clusters
extends = DYMO
network = GroundStation # Ignore warning
result-dir = ./results/ground_testing/

**.physicalEnvironment**.config = xmldoc("walls.xml")
**.radioMedium**.obstacleLossType = "IdealObstacleLoss"

*.nodeGround**.udpApp[0].typename = "UDPSink"
**.udpApp[*].typename = "UDPBasicApp" # All non-Ground nodes with BasicApp
**.udpApp[*].destAddresses = "10.2.0.1" # ... No specification of prefix?

**.mac.numSlots = ${NM} + 1

#*.nodeGround**.mac.clusterId = ${NM} # 0..3 for masters 4 for ground 5 for slave uplink
*.nodeGround**.radio.transmitter.communicationRange = 75m
*.nodeGround**.mobilityType = "CircleMobility"
*.nodeGround**.r = 85m
*.nodeGround**.startAngle = 0deg

					#								#
					# 			MultiNIC			#
					#								#
[Config MultiNIC]
extends = GroundStation
result-dir = ./results/multi_testing/

*.nodeSlave**.numRadios = 2
*.nodeMaster**.numRadios = 2

# Static role selection
*.nodeMaster[0].dymo.isGroundMaster = true
*.nodeGround[0].dymo.isGroundStation = true
*.node**.udpApp[*].joinLocalMulticastGroups = true

# NIC --- S2G ---
#
# TODO: Make sure bitrate is lower than S2S radios when testing
*.nodeGround**.wlan[0].typename = "IdealWirelessNic"
*.nodeGround**.wlan[0].bitrate = 1Mbps
*.nodeGround**.wlan[0].mac.address = "auto"
*.nodeGround**.wlan[0].mac.mtu = 0B # = 0B -> no fragmentation, passed up by I/F
*.nodeGround**.wlan[0].mac.headerLength = 10B
*.nodeGround**.wlan[0].mac.promiscuous = false
*.nodeGround**.wlan[0].mac.fullDuplex = false
*.nodeGround**.wlan[0].mac.useAck = true
*.nodeGround**.wlan[0].mac.ackTimeout = 1s

*.node**.wlan[1].typename = "IdealWirelessNic"
*.node**.wlan[1].bitrate = 1Mbps
*.node**.wlan[1].mac.address = "auto"
*.node**.wlan[1].mac.mtu = 0B # = 0B -> no fragmentation, passed up by I/F
*.node**.wlan[1].mac.headerLength = 10B
*.node**.wlan[1].mac.promiscuous = false
*.node**.wlan[1].mac.fullDuplex = false
*.node**.wlan[1].mac.useAck = true
*.node**.wlan[1].mac.ackTimeout = 1s

# Radio
#
*.nodeGround**.wlan[0].radio.radioMediumModule = "radioMedium[1]"
*.nodeGround**.wlan[0].radio.transmitter.preambleDuration = 0s
*.nodeGround**.wlan[0].radio.transmitter.headerBitLength = 0b
*.nodeGround**.wlan[0].radio.transmitter.detectionRange = 999m
*.nodeGround**.wlan[0].radio.transmitter.interferenceRange = 0m
*.nodeGround**.wlan[0].radio.transmitter.communicationRange = 75m # Should be enough only to talk to closest master
*.nodeGround**.wlan[0].radio.receiver.ignoreInterference = true

*.node**.wlan[1].radio.radioMediumModule = "radioMedium[1]"
*.node**.wlan[1].radio.transmitter.preambleDuration = 0s
*.node**.wlan[1].radio.transmitter.headerBitLength = 0b
*.node**.wlan[1].radio.transmitter.detectionRange = 999m
*.node**.wlan[1].radio.transmitter.interferenceRange = 0m
*.nodeSlave**.wlan[1].radio.transmitter.communicationRange = 75m
*.nodeMaster**.wlan[1].radio.transmitter.communicationRange = 225m
*.node**.wlan[1].radio.receiver.ignoreInterference = true

					#											#
					#			OrbitingGroundStation			#
					#											#

[Config Orbiting]
extends = MultiNIC
**nodeMaster**.speed = 1.125mps * 4
**nodeSlave**.speed = 1.5mps * 4

					#									#
					#			EnergyModelling			#
					#									#

[Config EnergyModelling]
extends = MultiNIC
#extends = OrbitingGroundStation
#extends = MultiNIC

*.node**.energyStorageType = "IdealEnergyStorage"
*.node**.radio.energyConsumerType = "StateBasedEnergyConsumer"

*.node**.radio.energyConsumer.offPowerConsumption = 0mW
*.node**.radio.energyConsumer.sleepPowerConsumption = 1mW
*.node**.radio.energyConsumer.switchingPowerConsumption = 1mW

*.node**.radio.energyConsumer.receiverIdlePowerConsumption = 2mW
*.node**.radio.energyConsumer.receiverBusyPowerConsumption = 5mW
*.node**.radio.energyConsumer.receiverReceivingPowerConsumption = 10mW

*.node**.radio.energyConsumer.transmitterIdlePowerConsumption = 2mW
*.node**.radio.energyConsumer.transmitterTransmittingPowerConsumption = 100mW