
#								#
# 			OneCluster			#
#								#

[Config OneCluster]
# TODO: Seperate ini files
network = Base
sim-time-limit = 100s
sim-time-limit.param-record-as-scalar = true

# Random Numbers
#
num-rngs = 3
**.mobility.rng-0 = 1
**.wlan[*].mac.rng-0 = 2

# Clusters
#
# TODO: Make better use of iteration variables
*.numMasters = ${NM=1}
*.numSlaves = ${NS=(${NM})*2}
*.slavesPerMaster = ${SPM=(${NS}/${NM})} # Dummy parameter

# Medium
#
*.radioMediumType = "IdealRadioMedium"
# Not ideal
*.radioMedium.mediumLimitCache.maxTransmissionDuration= 999s
*.radioMedium.mediumLimitCache.minInterferenceTime = 999s
#*.radioMedium.radioModeFilter = true # Do not send to radios which are no in recv or trancv
*.radioMedium.propagationType = "ConstantTimePropagation" # Doesn't affect transmission durations which is bits/bitrate
*.radioMedium.**.propagationTime = 0s

# Host
#
#*.node**.hasStatus = false # Lifecycle
*.node**.numUdpApps = 1

# Application
#
# --- Master 0
*.nodeMaster[0].udpApp[0].typename = "UDPSink"
*.nodeMaster[0].udpApp[0].localPort = 5000

# --- Slaves
*.nodeSlave[*].udpApp[0].typename = "UDPBasicApp"
*.nodeSlave[*].udpApp[0].destAddresses = "nodeMaster[0]"
*.nodeSlave[*].udpApp[0].packetName = "UDPDataSlave"
*.nodeSlave[*].udpApp[0].destPort = 5000
#*.nodeSlave[*].udpApp[0].messageLength = ${ML = 32, 64, 128, 256, 512}B
*.nodeSlave[*].udpApp[0].messageLength = ${ML = 128}B
**.udpApp[0].messageLength.param-record-as-scalar = true # Effects all 
*.nodeSlave[*].udpApp[0].startTime = ${SD} * ${NM} * 5ms # Five frames
# TODO: Adjust
*.nodeSlave[*].udpApp[0].sendInterval = truncnormal(1s, 0.05s)
#*.nodeSlave[*].udpApp[0].stopTime = # Default -1 (never)
#*.nodeSlave[*].udpApp[0].localPort = # Default -1
#*.nodeSlave[*].udpApp[0].localAddress = # ""
#*.nodeSlave[*].udpApp[0].timeToLive = # Default -1 (forever)

# Networking
#
# --- Basic static routing
#**.configurator.config = xml("<config><interface hosts='**' address='10.0.0.x' netmask='255.255.255.0'/><autoroute metric='errorRate'/></config>")
#**.configurator.optimizeRoutes = false
#**.routingTable.netmaskRoutes = ""
# --- AODV adjustments
*.configurator.addStaticRoutes = false

# NIC (All nodes, incl. ground)
#
*.node**.wlan[*].typename = "WirelessNic"
# --- MAC
*.node**.macType = "CubeMacLayer"
*.node**.mac.address = "auto"
*.node**.mac.bitrate = 2Mbps
#*.node**.mac.slotDuration = ${SD = 10, 25, 50, 75, 100}ms
*.node**.mac.slotDuration = ${SD = 100}ms
**.mac.slotDuration.param-record-as-scalar = true
*.node**.mac.headerLength = 10B
*.node**.mac.mtu = 0B # = 0B -> no fragmentation, passed up by I/F
*.node**.mac.numSlots = (${NM})+1 # +1 for the uplink slot
# TODO: Adjust
*.node**.mac.queueLength = 100
# --- Added
*.node**.mac.startTime = 0s
*.node**.mac.slotPadding = ${SD}ms * 0.1
*.node**.mac.timeoutDuration = ${SD}ms * 0.2
# --- --- Cluster configuration
*.nodeSlave**.mac.isSlave = true # Determines node behaviour mode
**.mac.clusterId.param-record-as-scalar = true ## Effects all
*.node**.mac.slavesInCluster = ${SPM} # Used to let Master know how many messages to expect during uplink slot
# --- Radio
*.node**.radioType = "IdealRadio"
*.node**.radio.displayCommunicationRange = true
# --- --- Transmitter / Receiver
*.node**.radio.transmitter.bitrate = 2Mbps
*.node**.radio.transmitter.preambleDuration = 0s
*.node**.radio.transmitter.headerBitLength = 0b
*.node**.radio.transmitter.detectionRange = 999m
*.node**.radio.transmitter.interferenceRange = 0m
*.nodeSlave**.radio.transmitter.communicationRange = 100m # Must also be set for ground
*.nodeMaster**.radio.transmitter.communicationRange = 235m
*.node**.radio.receiver.ignoreInterference = true

# Mobility
#
# --- Masters
*.nodeMaster[*].mobilityType = "CircleMobility"
*.node**.cx = 500m
*.node**.cy = 500m
*.node**.cz = 0m
*.nodeMaster**.r = 100m
*.nodeMaster**.startAngle = parentIndex() * (360deg/${NM})
# --- Slaves
*.nodeSlave[*].mobilityType = "CircleMobility"
*.nodeSlave**.r = 150m
# TODO: Write general rule for all
*.nodeSlave[0].**.startAngle = (parentIndex() * (360deg/${NM})) + 10deg
*.nodeSlave[1].**.startAngle = (parentIndex() * (360deg/${NM})) - 10deg

# Results
#
**.lo.**.scalar-recording = false
**.arp.**.scalar-recording = false
**.arp.**.vector-recording = false
**.udp.**.scalar-recording = false
**.udp.**.vector-recording = false
**.radio.**.scalar-recording = false
**.radio.**.vector-recording = false
**.radioMedium.**.scalar-recording = false
**.radioMedium.**.vector-recording = false

**.energyStorage.residualCapacity.vector-recording = true
**.udpApp[*].endToEndDelay.scalar-recording = true
**.udpApp[*].rcvdPk.vector-recording = true
**.udpApp[*].rcvdPk.scalar-recording = true
**.udpApp[*].rcvdPk.statistic-recording = true
**.udpApp[*].sentPk.vector-recording = true
**.udpApp[*].sentPk.scalar-recording = true
**.udpApp[*].throughput.scalar-recording = true
**.mac."MAC Access Delay".vector-recording = true
# Everything on
#**.statistic-recording = true
#**.scalar-recording = true
#**.vector-recording = true
#**.result-recording-modes = all

# Visualization
# TODO: Examine visualizer documentation further
#
#*.visualizer.physicalLinkVisualizer.packetNameFilter = "UDPData*"
#*.visualizer.dataLinkVisualizer.packetNameFilter = "UDPData*"
#*.visualizer.networkRouteVisualizer.packetNameFilter = "UDPData*"
#*.visualizer.mobilityVisualizer.displayMovementTrail = true

					#									#
					# 			FourClusters			#
					#									#

[Config FourClusters]
extends = OneCluster

# Must redefine cluster configuration iteration variables
*.numMasters = ${NMF=4}
*.numSlaves = ${NSF=(${NMF})*2}
*.slavesPerMaster = ${SPMF=(${NSF}/${NMF})} # Dummy parameter

# Apps
#
*.nodeMaster[1..].udpApp[0].typename = "UDPBasicApp"
*.nodeMaster[1..].udpApp[0].destAddresses = "nodeMaster[0]"
*.nodeMaster[1..].udpApp[0].packetName = "UDPDataMaster"
*.nodeMaster[1..].udpApp[0].destPort = 5000
*.nodeMaster[1..].udpApp[0].messageLength = ${ML}B
*.nodeSlave[*].udpApp[0].startTime = ${SD} * ${NMF} * 5ms # Five frames
# TODO: Adjust
*.nodeMaster[1..].udpApp[0].sendInterval = truncnormal(1s, 0.05s)

*.node**.mac.numSlots = (${NMF})+1 # +1 for the uplink slot
*.node**.mac.slavesInCluster = ${SPMF} # Used to let Master know how many control messages to expect in uplink slot

*.node*[*].wlan[*].radio.displayCommunicationRange = false
*.nodeSlave[*].wlan[*].radio.transmitter.communicationRange = 75m
*.nodeMaster[*].wlan[*].radio.transmitter.communicationRange = 225m

*.nodeSlave[..3]**clusterId = ancestorIndex(2)
*.nodeSlave[4..]**clusterId = (ancestorIndex(2) - ${NMF})
*.nodeMaster**clusterId = ancestorIndex(2) 

# Larger radii
*.nodeMaster**.r = 150m
*.nodeSlave**.r = 200m

*.nodeMaster**.startAngle = parentIndex() * (360deg/${NMF})
*.nodeSlave[..3]**.startAngle = (parentIndex() * (360deg/${NMF})) + 7deg
*.nodeSlave[4..]**.startAngle = (parentIndex() * (360deg/${NMF})) - 7deg

					#									#
					# 			GroundStation			#
					#									#

[Config GroundStation]
extends = FourClusters
network = GroundStation

*.numGround = 1

# Need a reasonable height relative to obstacles
*.node**.cz = 1.0m

# Obstacles
*.physicalEnvironment.config = xmldoc("walls.xml")
# TODO: Check further params
*.radioMedium.obstacleLossType = "IdealObstacleLoss"

*.nodeGround[0].udpApp[0].typename = "UDPSink"
*.nodeGround[0].udpApp[0].localPort = 5000

# All orbiting nodes now sending data
# TODO: Generalize further
*.node**udpApp[0].typename = "UDPBasicApp"
*.node**udpApp[0].destAddresses = "nodeGround[0]"
*.node**udpApp[0].packetName = "UDPForGround"
*.node**udpApp[0].destPort = 5000
*.node**udpApp[0].messageLength = ${ML}B
*.nodeSlave[*].udpApp[0].startTime = ${SD} * (${NMF} + 1) * 5ms # Five frames
# TODO: Adjust
*.node**udpApp[0].sendInterval = truncnormal(1s, 0.05s)

# NIC
#
**.mac.numSlots = ${NMF} + 2 # +1 for ground (acting like an extra master)

# Ground has to be able to participate in route negotiation
# TODO: Investiage differing approaches
*.nodeGround**.mac.clusterId = 4
**.mac.slavesInCluster = ${SPMF} # Used to let Master know how many control messages to expect in uplink slot

# Radio
**.radio.displayCommunicationRange = true
*.nodeGround**.radio.transmitter.communicationRange = 300m

# Mobility
*.nodeGround**mobilityType = "StationaryMobility"
*.nodeGround**initFromDisplayString = false
*.nodeGround**initialX = 505m
*.nodeGround**initialY = 460m
*.nodeGround**initialZ = 1.0m

#*.node**aodv.routingTableModule = "^.routingTable" # Defualt 	
#*.node**.aodv.interfaceTableModule = "^.interfaceTable"	# Defualt 
#*.node**.aodv.networkProtocolModule	= "^.networkLayer.ip" # Defualt 
*.node**.aodv.askGratuitousRREP = true	 # see RFC 3561: 6.6.3
*.node**.aodv.useHelloMessages = false	# see RFC 3561: 6.9 # Default false --- An analogue for beacons perhaps ---
#*.node**.aodv.useLocalRepair = false # see RFC 3561: 6.12 --- not implemented yet ---
#*.node**.aodv.udpPort = 654	
## it MUST NOT be negative; it MUST NOT be greater than MESSAGE_INTERVAL/2; it SHOULD NOT be greater (less???) than MESSAGE_INTERVAL/4.
#*.node**.aodv.maxPeriodicJitter = ${maxPeriodicJitter=(${helloInterval} * 0.25)s}
# jitter for externally triggered message generation and message forwarding
#*.node**.aodv.periodicJitter = uniform(0s, ${maxPeriodicJitter}) 
# RFC 5148: need more revise: As well as the decision as to whether to use jitter being dependent on the medium access control and lower layers, 
# the selection of the MAXJITTER parameter SHOULD be appropriate to those mechanisms.
#*.node**.aodv.maxJitter = ${maxJitter=5ms} 
#*.node**.aodv.jitter = uniform(0ms, ${maxJitter}) # jitter for broadcasts
*.node**.aodv.helloInterval = 2 * (${NMF} + 2) * ${SD}ms # every helloInterval seconds a node broadcasts Hello messages (if it is necessary)
#*.node**.aodv.allowedHelloLoss	= 2	# allowedHelloLoss * helloInterval is the lifetime value for Hello messages
# the timeout value for cached routes If Hello messages are used, 
# then the ACTIVE_ROUTE_TIMEOUT parameter value MUST be more than the value (ALLOWED_HELLO_LOSS * HELLO_INTERVAL).
*.node**.aodv.activeRouteTimeout = 25 * (${NMF} + 2) * ${SD}ms # NB 25 Frames 
*.node**.aodv.netDiameter = 32 # the maximum possible number of hops between two nodes in the network
*.node**.aodv.nodeTraversalTime = (${NMF} + 2) * ${SD}ms # an estimation of the average one-hop traversal time
#*.node**.aodv.rerrRatelimit = 10 # maximum number of RERR messages that the AODV may originate in 1s.
*.node**.aodv.rreqRetries = 3 # specifies the number of times AODV will repeat an expanded ring search for a destination
#*.node**.aodv.rreqRatelimit = 10 # maximum number of RREQ messages that the AODV may originate in 1s.
#*.node**.aodv.timeoutBuffer = 2 # plus time to wait for a delayed RREP (due to congestion) (to omit this buffer set it to 0)
*.node**.aodv.ttlStart = 5 # specifies the TTL value when initiating a route request
#*.node**.aodv.ttlIncrement = 2	# specifies the value by which the TTL will be incremented each time a RREQ is retransmitted
*.node**.aodv.ttlThreshold = 10	# the maximum value of TTL over which NET_DIAMETER value will be used to broadcast any RREQ
#*.node**.aodv.localAddTTL = 2 # it is used by the formula which calculates the initial TTL of the RREQ for a local repair

# Cannot define iteration variables by other iteration variables OMNeT? slavePerMaster works fine but these fall over
#*.node**.aodv.myRouteTimeout = 2 * activeRouteTimeout # the value of the lifetime field that a destination node places in RREPs
#*.node**.aodv.deletePeriod = 5 * max(activeRouteTimeout, helloInterval) # the time after which an expired route is deleted
#*.node**.aodv.netTraversalTime = 2 * nodeTraversalTime * netDiameter # an estimation of the traversal time for the complete network
#*.node**.aodv.blacklistTimeout = rreqRetries * netTraversalTime # the time after which a blacklisted node is removed from the blacklist
#*.node**.aodv.nextHopWait = nodeTraversalTime + 0.01s # timeout for a RREP-ACK
#*.node**.aodv.pathDiscoveryTime = 2 * netTraversalTime # buffer timeout for each broadcasted RREQ message

					#											#
					#			OrbitingGroundStation			#
					#											#

[Config OrbitingGroundStation]
extends = GroundStation
**nodeMaster**.speed = 1.125mps
**nodeSlave**.speed = 1.5mps

					#									#
					#			EnergyModelling			#
					#									#

[Config EnergyModelling]
extends = OrbitingGroundStation

*.node**.energyStorageType = "IdealEnergyStorage"
*.node**.radio.energyConsumerType = "StateBasedEnergyConsumer"

*.node**.radio.energyConsumer.offPowerConsumption = 0mW
*.node**.radio.energyConsumer.sleepPowerConsumption = 1mW
*.node**.radio.energyConsumer.switchingPowerConsumption = 1mW

*.node**.radio.energyConsumer.receiverIdlePowerConsumption = 2mW
*.node**.radio.energyConsumer.receiverBusyPowerConsumption = 5mW
*.node**.radio.energyConsumer.receiverReceivingPowerConsumption = 10mW

*.node**.radio.energyConsumer.transmitterIdlePowerConsumption = 2mW
*.node**.radio.energyConsumer.transmitterTransmittingPowerConsumption = 100mW

					#								#
					#			APSKRadio			#
					#								#

# Currently not allowing 'simultaneous' reception
[Config APSKRadio]
extends = EnergyModelling

*.radioMediumType = "APSKScalarRadioMedium"
*.radioMedium.backgroundNoise.power = -110dBm

# Issue not at the cache
*.radioMedium.mediumLimitCache.carrierFrequency = 2.412GHz 
*.radioMedium.mediumLimitCache.maxTransmissionDuration= 999s
*.radioMedium.mediumLimitCache.minInterferenceTime = 999s

*.radioMedium.propagationType = "ConstantTimePropagation"
*.radioMedium**.propagationTime = 0s

*.node**.radioType = "APSKScalarRadio" 

*.node**.radio.carrierFrequency = 2.412GHz 
*.node**.radio.bandwidth = 2MHz 

*.node**.radio.transmitter.power = 2mW 
*.node**.radio.transmitter.preambleDuration = 0s 
*.node**.radio.transmitter.headerBitLength = 0b 
*.node**.radio.transmitter.modulation = "BPSK"

*.node**.radio.receiver.sensitivity = -85dBm 
*.node**.radio.receiver.energyDetection = -85dBm 
*.node**.radio.receiver.snirThreshold = 4dB



